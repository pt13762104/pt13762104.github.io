{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"2024/08/24/chungkhoan/","title":"CHUNGKHOAN","text":"<p>Recently I revisited this problem which was intended to solve in \\(O(n)\\) (the problem asks to find the largest subarray which has \\(max-min&lt;=T\\)). But I can only think of a \\(O(n*log(n))\\) solution, so I coded the fastest \\(O(n*log(n))\\) solution yet using vectorized binary search and linear sparse table:</p> Code <pre><code>#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\nusing namespace std;\ntypedef int vec __attribute__((vector_size(32)));\nint lsb(int x)\n{\n    return x &amp; -x;\n}\nint smin[4000005], arr[4000005], smax[4000005], mmin[4000005], mmax[4000005];\nint b = 16;\nint n, t;\nint smmin(int r, int size = b)\n{\n    int dist_from_r = __lg(mmin[r] &amp; ((1 &lt;&lt; size) - 1));\n    return r - dist_from_r;\n}\nint smmax(int r, int size = b)\n{\n    int dist_from_r = __lg(mmax[r] &amp; ((1 &lt;&lt; size) - 1));\n    return r - dist_from_r;\n}\nint pmax(int x, int y)\n{\n    return arr[x] &gt; arr[y] ? x : y;\n}\nint pmin(int x, int y)\n{\n    return arr[x] &lt; arr[y] ? x : y;\n}\n// RMQ constant time insanity that I found online\nvoid build()\n{\n    int curr_mask = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        curr_mask = (curr_mask &lt;&lt; 1) &amp; ((1LL &lt;&lt; b) - 1);\n        while (curr_mask &gt; 0 &amp;&amp; pmin(i, i - __lg(lsb(curr_mask))) == i)\n        {\n            curr_mask ^= lsb(curr_mask);\n        }\n        curr_mask |= 1;\n        mmin[i] = curr_mask;\n    }\n    curr_mask = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        curr_mask = (curr_mask &lt;&lt; 1) &amp; ((1LL &lt;&lt; b) - 1);\n        while (curr_mask &gt; 0 &amp;&amp; pmax(i, i - __lg(lsb(curr_mask))) == i)\n        {\n            curr_mask ^= lsb(curr_mask);\n        }\n        curr_mask |= 1;\n        mmax[i] = curr_mask;\n    }\n    for (int i = 0; i &lt; (n &gt;&gt; 4); i++)\n    {\n        smin[i] = smmin(b * i + b - 1);\n        smax[i] = smmax(b * i + b - 1);\n    }\n    for (int j = 1; (1 &lt;&lt; j) &lt;= (n &gt;&gt; 4); j++)\n        for (int i = 0; i + (1 &lt;&lt; j) &lt;= (n &gt;&gt; 4); i++)\n        {\n            smin[(n &gt;&gt; 4) * j + i] = pmin(smin[(n &gt;&gt; 4) * (j - 1) + i], smin[(n &gt;&gt; 4) * (j - 1) + i + (1 &lt;&lt; (j - 1))]);\n            smax[(n &gt;&gt; 4) * j + i] = pmax(smax[(n &gt;&gt; 4) * (j - 1) + i], smax[(n &gt;&gt; 4) * (j - 1) + i + (1 &lt;&lt; (j - 1))]);\n        }\n}\nvec query8_0(vec &amp;s, vec &amp;t)\n{\n    vec res;\n    for (int i = 0; i &lt; 8; i++)\n    {\n        int l = s[i], r = t[i];\n        if (r - l + 1 &lt;= b)\n        {\n            res[i] = arr[smmax(r, r - l + 1)] - arr[smmin(r, r - l + 1)];\n            continue;\n        }\n        int ansmax = pmax(smmax(l + b - 1), smmax(r)), ansmin = pmin(smmin(l + b - 1), smmin(r));\n        int x = (l &gt;&gt; 4) + 1, y = (r &gt;&gt; 4) - 1;\n        if (x &lt;= y)\n        {\n            int j = __lg(y - x + 1);\n            ansmax = pmax(ansmax, pmax(smax[(n &gt;&gt; 4) * j + x], smax[(n &gt;&gt; 4) * j + y - (1 &lt;&lt; j) + 1]));\n            ansmin = pmin(ansmin, pmin(smin[(n &gt;&gt; 4) * j + x], smin[(n &gt;&gt; 4) * j + y - (1 &lt;&lt; j) + 1]));\n        }\n        res[i] = arr[ansmax] - arr[ansmin];\n    }\n    return res;\n}\nbool cmp_l(vec &amp;a, vec &amp;b)\n{\n    vec c = a &lt;= b;\n    return c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7];\n}\nint maxvec(vec a)\n{\n    return max(max(max(a[0], a[1]), max(a[2], a[3])), max(max(a[4], a[5]), max(a[6], a[7])));\n}\nvec nm;\nvec bs_min(vec &amp;l)\n{\n    // SIMD binary search\n    vec s = l, r = nm;\n    while (cmp_l(l, r))\n    {\n        vec mid = (l + r) &gt;&gt; 1, q4 = query8_0(s, mid);\n        l = l - (mid - l + 1) * (q4 &lt;= t);\n        r = r - (mid - r - 1) * (q4 &gt; t);\n    }\n    return r - s + 1;\n}\nconst int BUF_SZ = 33550336;\ninline namespace Input\n{\nchar buf[BUF_SZ];\nint pos;\nint len;\nchar next_char()\n{\n    if (pos == len)\n    {\n        pos = 0;\n        len = (int)fread(buf, 1, BUF_SZ, stdin);\n        if (!len)\n        {\n            return EOF;\n        }\n    }\n    return buf[pos++];\n}\nint read_int()\n{\n    int x;\n    char ch;\n    int sgn = 1;\n    while (!isdigit(ch = next_char()))\n    {\n        if (ch == '-')\n        {\n            sgn *= -1;\n        }\n    }\n    x = ch - '0';\n    while (isdigit(ch = next_char()))\n    {\n        x = x * 10 + (ch - '0');\n    }\n    return x * sgn;\n}\n}; // namespace Input\ninline namespace Output\n{\nchar buf[BUF_SZ];\nint pos;\nvoid flush_out()\n{\n    fwrite(buf, 1, pos, stdout);\n    pos = 0;\n}\nvoid write_char(char c)\n{\n    if (pos == BUF_SZ)\n    {\n        flush_out();\n    }\n    buf[pos++] = c;\n}\nvoid write_int(int x)\n{\n    static char num_buf[100];\n    if (x &lt; 0)\n    {\n        write_char('-');\n        x *= -1;\n    }\n    int len = 0;\n    for (; x &gt;= 10; x /= 10)\n    {\n        num_buf[len++] = (char)('0' + (x % 10));\n    }\n    write_char((char)('0' + x));\n    while (len)\n    {\n        write_char(num_buf[--len]);\n    }\n    write_char('\\n');\n} // auto-flush output when program exits\n#include &lt;cassert&gt;\nvoid init_output()\n{\n    assert(atexit(flush_out) == 0);\n}\n}; // namespace Output\nsigned main()\n{\n    init_output();\n    t = read_int();\n    n = read_int();\n    for (int i = 0; i &lt; n; i++)\n        arr[i] = read_int();\n    build();\n    int res = 0;\n    nm = vec{n - 1, n - 1, n - 1, n - 1, n - 1, n - 1, n - 1, n - 1};\n    vec shift{0, 1, 2, 3, 4, 5, 6, 7};\n    for (int i = 0; i &lt; n / 8; i++)\n    {\n        vec vi = shift + 8 * i;\n        res = max(res, maxvec(bs_min(vi)));\n        // Fast cut\n        if (n - res &lt; 8 * (i + 1))\n            break;\n    }\n    if (n % 8)\n    {\n        int n4 = (n &gt;&gt; 3) &lt;&lt; 3;\n        vec c{n4, n4, n4, n4, n4, n4, n4, n4};\n        for (int i = 0; i &lt; n % 8; i++)\n            c[i]++;\n        res = max(res, maxvec(bs_min(c)));\n    }\n    write_int(res);\n}\n</code></pre>"},{"location":"2023/11/12/first/","title":"First","text":"<p>This is my first post on my site v3.</p> <ul> <li>New features:<ul> <li>Move to MkDocs</li> <li>Faster &amp; less bloated (only &lt;0.5s build time vs 13s for (unoptimized) v2)</li> <li>...</li> </ul> </li> </ul>"},{"location":"2024/06/17/h%C3%A0ng-c%C3%A2y/","title":"H\u00e0ng c\u00e2y","text":""},{"location":"2024/06/17/h%C3%A0ng-c%C3%A2y/#1-subtask-1","title":"1. Subtask 1","text":"<p>Ta l\u1eb7p qua t\u1eebng ph\u1ea7n t\u1eed trong m\u1ea3ng, ch\u1ecdn ra nh\u1eefng ph\u1ea7n t\u1eed th\u1ecfa m\u00e3n r\u1ed3i t\u00ednh gi\u00e1 tr\u1ecb. \u0110pt: \\(O(nq)\\).</p>"},{"location":"2024/06/17/h%C3%A0ng-c%C3%A2y/#2-subtask-2","title":"2. Subtask 2","text":"<p>Ta s\u1ebd x\u1eed l\u00fd tr\u01b0\u1edbc c\u00e1c truy v\u1ea5n \\([l,r]\\) v\u1edbi l,r thu\u1ed9c m\u1ea3ng. Ta \u0111\u1eb7t c\u00e1c m\u1ea3ng next, prev, p \u0111\u1ec3 x\u1eed l\u00fd thao t\u00e1c x\u00f3a ph\u1ea7n t\u1eed (t\u0103ng \\(l\\) l\u00ean -&gt; x\u00f3a d\u1ea7n ph\u1ea7n t\u1eed \u0111i). Ta l\u1eb7p r, sau \u0111\u00f3 ch\u00e8n c\u00e1c ph\u1ea7n t\u1eed n\u1eb1m trong kho\u1ea3ng \\([0,r]\\) v\u00e0o m\u1ea3ng p. M\u1ea3ng next s\u1ebd l\u01b0u \\(i+1\\) v\u1edbi ph\u1ea7n t\u1eed th\u1ee9 \\(i\\), v\u00e0 m\u1ea3ng prev s\u1ebd l\u01b0u ph\u1ea7n t\u1eed th\u1ee9 \\(i-1\\). Khi ch\u00fang ta mu\u1ed1n x\u00f3a ph\u1ea7n t\u1eed th\u1ee9 \\(i\\) trong m\u1ea3ng p th\u00ec ta s\u1ebd c\u1eadp nh\u1eadt next v\u00e0 prev \u0111\u1ec3 b\u1ecf qua ph\u1ea7n t\u1eed \u0111\u1ea5y v\u00e0 c\u1eadp nh\u1eadt ch\u00eanh l\u1ec7ch. Khi ch\u00fang ta x\u1eed l\u00fd \u0111\u01b0\u1ee3c h\u1ebft \\([l,r]\\) trong m\u1ea3ng th\u00ec ch\u1ec9 c\u1ea7n cnp \u0111\u1ec3 t\u00ecm \u0111\u00e1p \u00e1n.</p> Code <pre><code>void update(int *p, int *prev, int *next, int i, long long &amp;sum, int size)\n{\n    if (next[i] != size &amp;&amp; prev[i] != -1)\n    {\n        sum += abs(p[next[i]] - p[prev[i]]);\n    }\n    if (next[i] != size)\n    {\n        sum -= abs(p[next[i]] - p[i]);\n        prev[next[i]] = prev[i];\n    }\n    if (prev[i] != -1)\n    {\n        sum -= abs(p[prev[i]] - p[i]);\n        next[prev[i]] = next[i];\n    }\n}\nvoid sub2(vector&lt;int&gt; &amp;p, vector&lt;query *&gt; &amp;queries)\n{\n    int distinct = 0;\n    bool cnt[401];\n    fill(cnt, cnt + 401, 0);\n    for (int i = 0; i &lt; n; i++)\n    {\n        if (!cnt[p[i]])\n        {\n            cnt[p[i]] = 1;\n            distinct++;\n        }\n    }\n    long long mp[401][401];\n    vector&lt;int&gt; p2 = p;\n    sort(p.begin(), p.end());\n    unique(p.begin(), p.end());\n    while (p.size() != distinct)\n        p.pop_back();\n    int p3[n], prev[n], next[n];\n    for (int i = 0; i &lt; p.size(); i++)\n    {\n        vector&lt;int&gt; idx[401];\n        int counter = 0;\n        long long sum = 0;\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (p2[j] &lt;= p[i])\n            {\n                p3[counter] = p2[j];\n                prev[counter] = counter - 1;\n                next[counter] = counter + 1;\n                idx[p2[j]].push_back(counter);\n                if (counter &gt;= 1)\n                    sum += abs(p3[counter - 1] - p2[j]);\n                counter++;\n            }\n        }\n        mp[p[0]][p[i]] = sum;\n        for (int j = 1; j &lt;= i; j++)\n        {\n            for (auto &amp;k : idx[p[j - 1]])\n            {\n                update(p3, prev, next, k, sum, counter);\n            }\n            mp[p[j]][p[i]] = sum;\n        }\n    }\n    for (int i = 0; i &lt; q; i++)\n    {\n        int l = queries[i]-&gt;l, r = queries[i]-&gt;r;\n        int ll = lower_bound(p.begin(), p.end(), l) - p.begin();\n        int rr = upper_bound(p.begin(), p.end(), r) - p.begin() - 1;\n        if (ll &gt; rr)\n        {\n            cout &lt;&lt; 0 &lt;&lt; '\\n';\n            continue;\n        }\n        cout &lt;&lt; mp[p[ll]][p[rr]] &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>\u0110pt: \\(O((n+h)*h+q\\log(h))\\).</p>"},{"location":"2024/06/17/h%C3%A0ng-c%C3%A2y/#3-subtask-3","title":"3. Subtask 3","text":"<p>V\u1edbi subtask 3, ta ch\u1ec9 c\u1ea7n ph\u1ea3i ch\u00e8n v\u00e0 x\u00f3a c\u00e1c ph\u1ea7n t\u1eed 1 c\u00e1ch tr\u00e2u. Do gi\u1edbi h\u1ea1n c\u1ee7a subtask n\u00e0y khi\u1ebfn cho ch\u1ec9 c\u00f3 \\(O(n)\\) ph\u1ea7n t\u1eed b\u1ecb ch\u00e8n th\u00eam / x\u00f3a \u0111i. Ta v\u1eabn s\u1eed d\u1ee5ng ch\u1eb7t nh\u1ecb ph\u00e2n \u0111\u1ec3 t\u00ecm k\u1ebft qu\u1ea3 (chuy\u1ec3n \\([l,r]\\) th\u00e0nh \\([l',r']\\) g\u1ea7n nh\u1ea5t m\u00e0 \\(l',r'\\) thu\u1ed9c m\u1ea3ng).</p> Code <pre><code>void add(map&lt;int, int&gt; &amp;s, int i, int x, long long &amp;sum)\n{\n    auto it = s.lower_bound(i), it2 = it;\n    if (it != s.begin())\n        it2--;\n    if (it != s.end() &amp;&amp; it != s.begin())\n    {\n        sum -= abs((*it).second - (*it2).second);\n    }\n    if (it != s.end())\n    {\n        sum += abs((*it).second - x);\n    }\n    if (it != s.begin())\n    {\n        sum += abs((*it2).second - x);\n    }\n    s[i] = x;\n}\nvoid rmv(map&lt;int, int&gt; &amp;s, int i, long long &amp;sum)\n{\n    auto it = s.lower_bound(i), it2 = it, it3 = it;\n    if (it != s.begin())\n        it3--;\n    it2++;\n    if (it2 != s.end() &amp;&amp; it != s.begin())\n    {\n        sum += abs((*it2).second - (*it3).second);\n    }\n    if (it2 != s.end())\n    {\n        sum -= abs((*it2).second - (*it).second);\n    }\n    if (it != s.begin())\n    {\n        sum -= abs((*it3).second - (*it).second);\n    }\n    s.erase(it);\n}\nvoid sub3(vector&lt;int&gt; &amp;p, vector&lt;query *&gt; &amp;queries)\n{\n    map&lt;int, vector&lt;int&gt;&gt; idx;\n    for (auto &amp;i : p)\n        idx[i].push_back(&amp;i - &amp;p.front());\n    long long sum = 0;\n    map&lt;int, int&gt; s;\n    sort(p.begin(), p.end());\n    unique(p.begin(), p.end());\n    while (p.size() != idx.size())\n        p.pop_back();\n    int oldl = queries.front()-&gt;l, oldr = queries.front()-&gt;r, oldll, oldrr;\n    oldll = lower_bound(p.begin(), p.end(), oldl) - p.begin();\n    oldrr = upper_bound(p.begin(), p.end(), oldr) - p.begin() - 1;\n    for (int i = oldll; i &lt;= oldrr; i++)\n    {\n        for (auto &amp;k : idx[p[i]])\n        {\n            add(s, k, p[i], sum);\n        }\n    }\n    cout &lt;&lt; sum &lt;&lt; '\\n';\n    for (int i = 1; i &lt; q; i++)\n    {\n        int l = queries[i]-&gt;l, r = queries[i]-&gt;r;\n        int ll = lower_bound(p.begin(), p.end(), l) - p.begin();\n        int rr = upper_bound(p.begin(), p.end(), r) - p.begin() - 1;\n        while (ll &gt; oldll)\n        {\n            for (auto &amp;k : idx[p[oldll]])\n            {\n                rmv(s, k, sum);\n            }\n            oldll++;\n        }\n        while (rr &gt; oldrr)\n        {\n            oldrr++;\n            for (auto &amp;k : idx[p[oldrr]])\n            {\n                add(s, k, p[oldrr], sum);\n            }\n        }\n        if (ll &gt; rr)\n        {\n            cout &lt;&lt; 0 &lt;&lt; '\\n';\n            continue;\n        }\n        cout &lt;&lt; sum &lt;&lt; '\\n';\n    }\n}\n</code></pre> <p>\u0110pt: \\(O((n+q)\\log(n))\\).</p>"},{"location":"2024/06/17/h%C3%A0ng-c%C3%A2y/#4-subtask-4","title":"4. Subtask 4","text":"<p>Ta c\u1eaft m\u1ea3ng ra th\u00e0nh c\u00e1c ph\u1ea7n, m\u1ed7i ph\u1ea7n c\u00f3 k\u00edch th\u01b0\u1edbc \\(BLOCK\\). S\u1eed d\u1ee5ng thu\u1eadt to\u00e1n g\u1ea7n gi\u1ed1ng v\u1edbi sub2 tr\u00ean m\u1ed7i ph\u1ea7n tuy nhi\u00ean ta s\u1ebd l\u01b0u v\u1ecb tr\u00ed c\u1ee7a \\(l',r'\\) thay v\u00ec l\u01b0u \\(l',r'\\), ta s\u1ebd l\u1ea5y \u0111\u01b0\u1ee3c k\u1ebft qu\u1ea3 cho m\u1ed7i ph\u1ea7n. Ta s\u1eed d\u1ee5ng RMQ \u0111\u1ec3 t\u00ecm ph\u1ea7n t\u1eed g\u1ea7n nh\u1ea5t v\u1edbi 2 \u0111\u1ea7u m\u00fat n\u1eb1m trong kho\u1ea3ng \\([l,r]\\). (V\u00ec vi\u1ec7c g\u1ed9p c\u00e1c ph\u1ea7n l\u1ea1i c\u1ea7n ph\u1ea3i c\u00f3 2 ph\u1ea7n t\u1eed \u0111\u1ea7u m\u00fat \u0111\u1ec3 t\u00ecm ch\u00eanh l\u1ec7ch \u0111\u00fang). Ta s\u1ebd s\u1eafp x\u1ebfp l\u1ea1i c\u00e1c truy v\u1ea5n theo \\(l\\) r\u1ed3i theo \\(r\\) \u0111\u1ec3 t\u00ednh v\u1ecb tr\u00ed c\u1ee7a \\(l',r'\\) nhanh h\u01a1n (m\u1ea5t \\(O(q*n/BLOCK)\\) thay v\u00ec \\(O(q*n/BLOCK*\\log(BLOCK))\\)). Vi\u1ec7c x\u1eed l\u00fd nh\u01b0 subtask 2 s\u1ebd m\u1ea5t \\(O(BLOCK*n)\\).</p> Code <pre><code>struct result\n{\n    long long query;\n    int first, last;\n};\nstruct block\n{\n    // blk^2\n    long long mp[BLOCK][BLOCK];\n    // blk*log(blk)\n    int rmq[lgblk][BLOCK], rmq2[lgblk][BLOCK];\n    // blk\n    vector&lt;int&gt; p, p2;\n    result query(int l, int r, int ll, int rr)\n    {\n        if (ll &gt; rr)\n            return {0, -1, -1};\n        int lg = _lg[rr - ll + 1];\n        return {mp[ll][rr], p2[min(rmq[lg][ll], rmq[lg][rr - (1 &lt;&lt; lg) + 1])],\n                p2[max(rmq2[lg][ll], rmq2[lg][rr - (1 &lt;&lt; lg) + 1])]};\n    }\n};\nvoid process(vector&lt;int&gt; p, block &amp;blk)\n{\n    map&lt;int, vector&lt;int&gt;&gt; idx;\n    for (int i = 0; i &lt; BLOCK; i++)\n    {\n        idx[p[i]].push_back(i);\n    }\n    blk.p2 = p;\n    sort(p.begin(), p.end());\n    unique(p.begin(), p.end());\n    vector&lt;int&gt; orders(BLOCK);\n    while (p.size() != idx.size())\n        p.pop_back();\n    for (int i = 0; i &lt; BLOCK; i++)\n        orders[i] = lower_bound(p.begin(), p.end(), blk.p2[i]) - p.begin();\n    blk.p = p;\n    for (int i = 0; i &lt; p.size(); i++)\n    {\n        blk.rmq[0][i] = idx[p[i]].front();\n        blk.rmq2[0][i] = idx[p[i]].back();\n    }\n    for (int i = 1; i &lt;= lgblk; i++)\n    {\n        for (int j = 0; j + (1 &lt;&lt; i) &lt;= p.size(); j++)\n        {\n            blk.rmq[i][j] =\n                min(blk.rmq[i - 1][j], blk.rmq[i - 1][j + (1 &lt;&lt; (i - 1))]);\n            blk.rmq2[i][j] =\n                max(blk.rmq2[i - 1][j], blk.rmq2[i - 1][j + (1 &lt;&lt; (i - 1))]);\n        }\n    }\n    int p3[n], prev[n], next[n];\n    for (int j = 0; j &lt; p.size(); j++)\n    {\n\n        vector&lt;int&gt; idx[BLOCK];\n        int counter = 0;\n        long long sum = 0;\n        for (int i = 0; i &lt; BLOCK; i++)\n        {\n            if (orders[i] &lt;= j)\n            {\n                p3[counter] = blk.p2[i];\n                prev[counter] = counter - 1;\n                next[counter] = counter + 1;\n                idx[orders[i]].push_back(counter);\n                if (counter &gt;= 1)\n                    sum += abs(p3[counter - 1] - blk.p2[i]);\n                counter++;\n            }\n        }\n        blk.mp[0][j] = sum;\n        for (int i = 1; i &lt;= j; i++)\n        {\n            for (auto k : idx[i - 1])\n            {\n                update(p3, prev, next, k, sum, counter);\n            }\n            blk.mp[i][j] = sum;\n        }\n    }\n}\nvoid sub4(vector&lt;int&gt; &amp;p, vector&lt;query *&gt; &amp;queries)\n{\n    block blks[n / BLOCK];\n    for (int i = 0; i &lt; n / BLOCK; i++)\n    {\n        process(vector&lt;int&gt;(p.begin() + i * BLOCK, p.begin() + (i + 1) * BLOCK),\n                blks[i]);\n    }\n    vector&lt;int&gt; ll(n / BLOCK), rr(n / BLOCK);\n    sort(queries.begin(), queries.end(),\n        [](query *a, query *b)\n        { return a-&gt;l &lt; b-&gt;l; });\n    for (auto &amp;i : queries)\n    {\n        for (int j = 0; j &lt; n / BLOCK; j++)\n        {\n            int psz = blks[j].p.size();\n            while (ll[j] &lt; psz &amp;&amp; blks[j].p[ll[j]] &lt; i-&gt;l)\n                ll[j]++;\n        }\n        i-&gt;ll = ll;\n    }\n    sort(queries.begin(), queries.end(),\n        [](query *a, query *b)\n        { return a-&gt;r &lt; b-&gt;r; });\n    vector&lt;long long&gt; qres(q);\n    for (auto &amp;i : queries)\n    {\n        long long res = 0;\n        vector&lt;int&gt; acc;\n        for (int j = 0; j &lt; n / BLOCK; j++)\n        {\n            int psz = blks[j].p.size();\n            while (rr[j] &lt; psz &amp;&amp; blks[j].p[rr[j]] &lt;= i-&gt;r)\n                rr[j]++;\n            result x = blks[j].query(i-&gt;l, i-&gt;r, i-&gt;ll[j], rr[j] - 1);\n            res += x.query;\n            if (x.first != -1)\n            {\n                acc.push_back(x.first);\n                acc.push_back(x.last);\n            }\n        }\n        for (int i = 1; i + 1 &lt; acc.size(); i += 2)\n            res += abs(acc[i] - acc[i + 1]);\n        qres[i-&gt;id] = res;\n    }\n    for (auto &amp;i : qres)\n        cout &lt;&lt; i &lt;&lt; '\\n';\n}\n</code></pre> <p>Ch\u1ecdn \\(BLOCK=\\sqrt{n}\\) ta c\u00f3 \u0111pt \\(O((n+q)\\sqrt{n})\\).</p>"},{"location":"2023/11/13/sympy/","title":"SymPy","text":"<p>I have created a SymPy package that runs on ARM64, based on Alpine (note: requires Termux,proot/chroot OR any rooted computer that is ARM64 (e.g. RPi,etc.)) just for fun (to see how small it can be).</p> <p>Download link</p> <ul> <li>Usage:<ul> <li>Extract this file to your home directory (e.g by <code>tar -xzf ../sympy.cmax.tgz /home/...</code>).</li> <li>Run <code>chroot /home/.../alpine /bin/bash -l</code></li> <li>You should see a Python shell with SymPy loaded. (Note: exiting the shell will stop the chroot. To stop this (e.g. for customization,etc..) remove the <code>exit 0</code> line in the <code>.../alpine/etc/profile</code> file.)</li> </ul> </li> </ul>"},{"location":"archive/2024/","title":"2024","text":""},{"location":"archive/2023/","title":"2023","text":""},{"location":"category/cp/","title":"CP","text":""},{"location":"category/fun/","title":"Fun","text":""},{"location":"category/my-site/","title":"My site","text":""}]}